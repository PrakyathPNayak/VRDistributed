<!DOCTYPE html>
<html>
<head>
    <title>Secure Video Stream</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.3.2/jsencrypt.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            margin: 0;
        }
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            margin: 20px auto;
            background: black;
            border: 2px solid #333;
        }
        .controls, .quality-control {
            text-align: center;
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
        }
        .status {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        .debug {
            margin-top: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Secure Video Stream</h1>
        <div id="status" class="status">Connecting...</div>
        <canvas id="canvas" width="960" height="540"></canvas>

        <div class="controls">
            <button id="pauseBtn" onclick="sendControl('pause')">Pause</button>
            <button id="resumeBtn" onclick="sendControl('resume')" disabled>Resume</button>
            <button id="disconnectBtn" onclick="disconnect()">Disconnect</button>
        </div>

        <div class="quality-control">
            <label for="quality">JPEG Quality:</label>
            <input type="range" id="quality" min="1" max="100" value="20">
            <span id="qualityValue">20</span>
            <button onclick="setQuality()">Apply</button>
        </div>

        <div id="debug" class="debug"></div>
    </div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const qualitySlider = document.getElementById('quality');
    const qualityValue = document.getElementById('qualityValue');

    let socket, aesKey, iv, isConnected = false, streamReady = false;

    qualitySlider.oninput = () => {
        qualityValue.textContent = qualitySlider.value;
    };

    const updateStatus = (msg, type = '') => {
        statusDiv.textContent = msg;
        statusDiv.className = `status ${type}`;
    };

    const connect = () => {
        const address = window.location.host;
        const wsProtocol = window.location.protocol === "https:" ? "wss" : "ws";
        const wsUrl = `${wsProtocol}://${window.location.host}/ws/stream/`;
        socket = new WebSocket(wsUrl);
        socket.binaryType = 'arraybuffer';
        console.log('Connecting to WebSocket with address: ' + address);

        socket.onopen = () => {
            isConnected = true;
            updateStatus('Connected, awaiting RSA key...', 'connected');
        };
        
        socket.onclose = () => {
            updateStatus('Connection closed', 'error');
            isConnected = streamReady = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('resumeBtn').disabled = true;
        };
        
        socket.onerror = (error) => {
            updateStatus('WebSocket error occurred', 'error');
        };

        socket.onmessage = async event => {
            if (typeof event.data === 'string') {
                const msg = JSON.parse(event.data);
                await handleControlMessage(msg);
            } else {
                await handleEncryptedFrame(event.data);
            }
        };
    };

    const base64Encode = buffer => btoa(String.fromCharCode(...buffer));
    const base64Decode = str => new Uint8Array([...atob(str)].map(c => c.charCodeAt(0)));

    async function performKeyExchange(encodedPem) {
        try {
            const pem = atob(encodedPem);
            const encrypt = new JSEncrypt();
            encrypt.setPublicKey(pem);

            const aesKeyRaw = crypto.getRandomValues(new Uint8Array(32));
            iv = crypto.getRandomValues(new Uint8Array(12));

            aesKey = await crypto.subtle.importKey(
                'raw',
                aesKeyRaw,
                { name: 'AES-GCM' },
                false,
                ['decrypt']
            );

            const aesKeyB64 = btoa(String.fromCharCode(...aesKeyRaw));
            const encryptedKey = encrypt.encrypt(aesKeyB64);

            if (!encryptedKey) throw new Error('RSA encryption failed');

            socket.send(JSON.stringify({
                type: 'aes_key_exchange',
                encrypted_key: encryptedKey,
                iv: base64Encode(iv)
            }));

            updateStatus("Key exchange sent, waiting for camera...", 'connected');

        } catch (err) {
            updateStatus(`Key exchange failed: ${err.message}`, 'error');
        }
    }
    const handleControlMessage = async msg => {
        if (msg.type === 'rsa_public_key') {
            await performKeyExchange(msg.key);
        } 
        else if (msg.type === 'stream_ready') {
            updateStatus('Streaming video...', 'connected');
            streamReady = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('resumeBtn').disabled = true;
        } 
        else if (msg.type === 'status') {
            updateStatus(msg.message, 'connected');
            if (msg.message.includes('paused')) {
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('resumeBtn').disabled = false;
            } else if (msg.message.includes('resumed')) {
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('resumeBtn').disabled = true;
            }
        } 
        else if (msg.type === 'error') {
            updateStatus(`Error: ${msg.message}`, 'error');
        }
    };

    const handleEncryptedFrame = async (data) => {
        try {
            if (!aesKey || !streamReady) {
                return;
            }

            const headerSize = 16;
            const nonceSize = 12;
            const tagSize = 16;

            if (data.byteLength <= headerSize + nonceSize + tagSize) {
                return;
            }

            const headerView = new DataView(data, 0, headerSize);
            const timestamp = headerView.getFloat64(0, true);
            const sequence = headerView.getUint32(8, true);
            const totalEncryptedSize = headerView.getUint32(12, true);

            if (data.byteLength !== headerSize + totalEncryptedSize) {
                return;
            }

            const frameNonce = data.slice(headerSize, headerSize + nonceSize);
            const ciphertextSize = totalEncryptedSize - nonceSize - tagSize;
            const ciphertext = data.slice(headerSize + nonceSize, headerSize + nonceSize + ciphertextSize);
            const tag = data.slice(headerSize + nonceSize + ciphertextSize);

            const encryptedDataWithTag = new Uint8Array(ciphertext.byteLength + tag.byteLength);
            encryptedDataWithTag.set(new Uint8Array(ciphertext), 0);
            encryptedDataWithTag.set(new Uint8Array(tag), ciphertext.byteLength);

            const decrypted = await crypto.subtle.decrypt({
                name: "AES-GCM",
                iv: frameNonce,
                tagLength: 128
            }, aesKey, encryptedDataWithTag);

            const blob = new Blob([decrypted], { type: 'image/jpeg' });
            const img = new Image();
            img.onload = () => {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                URL.revokeObjectURL(img.src);
            };
            img.onerror = () => {
                URL.revokeObjectURL(img.src);
            };
            img.src = URL.createObjectURL(blob);

        } catch (err) {
            // Optionally handle decryption errors silently
        }
    };

    const sendControl = action => {
        if (socket && isConnected) {
            socket.send(JSON.stringify({ type: action }));
        }
    };

    const setQuality = () => {
        if (socket && isConnected) {
            const quality = parseInt(qualitySlider.value);
            socket.send(JSON.stringify({
                type: 'quality',
                value: quality
            }));
        }
    };

    const disconnect = () => {
        if (socket) {
            socket.send(JSON.stringify({ type: 'terminate' }));
            socket.close();
        }
    };

    window.onload = connect;
    window.onbeforeunload = () => {
        if (socket) {
            socket.close();
        }
    };
</script>
</body>
</html>